{"version":3,"file":"index.js","sources":["../src/one.ts","../src/all.ts","../src/util.ts","../src/stringToObjectStyle.ts","../src/mappings.ts","../src/getAttributes.ts","../src/handlers.ts","../src/helpers.ts","../src/index.ts"],"sourcesContent":["import type { Node, RootNode, ElementNode } from 'svg-parser'\nimport type { Helpers } from './helpers'\nimport type * as t from '@babel/types'\n\nexport const one = (\n  h: Helpers,\n  node: Node,\n  parent?: RootNode | ElementNode,\n): t.JSXElement | t.ExpressionStatement | t.JSXExpressionContainer | null => {\n  const type = node && node.type\n  const fn = h.handlers[type]\n\n  /* Fail on non-nodes. */\n  if (!type) {\n    throw new Error(`Expected node, got \\`${node}\\``)\n  }\n\n  if (!fn) {\n    throw new Error(`Node of type ${type} is unknown`)\n  }\n\n  // @ts-ignore\n  return fn(h, node, parent)\n}\n","import { one } from './one'\nimport type * as t from '@babel/types'\nimport type { RootNode, ElementNode } from 'svg-parser'\nimport type { Helpers } from './helpers'\n\n/* Transform the children of `parent`. */\nexport const all = (\n  helpers: Helpers,\n  parent: RootNode | ElementNode,\n): (t.JSXElement | t.JSXExpressionContainer)[] => {\n  const nodes = parent.children || []\n  const { length } = nodes\n  const values = []\n  let index = -1\n\n  while (++index < length) {\n    const node = nodes[index]\n    if (typeof node !== 'string') {\n      const result = one(helpers, node, parent)\n      values.push(result)\n    }\n  }\n\n  return values.filter(Boolean) as (t.JSXElement | t.JSXExpressionContainer)[]\n}\n","/**\n * Determines if the specified string consists entirely of numeric characters.\n */\nexport const isNumeric = (value: number | string): boolean => {\n  // @ts-ignore\n  return !Number.isNaN(value - parseFloat(value))\n}\n\n/**\n * Convert a hyphenated string to camelCase.\n */\nexport const hyphenToCamelCase = (string: string): string => {\n  return string.replace(/-(.)/g, (_, chr) => chr.toUpperCase())\n}\n\n/**\n * Trim the specified substring off the string. If the string does not end\n * with the specified substring, this is a no-op.\n *\n * @param {string} haystack String to search in\n * @param {string} needle   String to search for\n */\nexport const trimEnd = (haystack: string, needle: string): string => {\n  return haystack.endsWith(needle)\n    ? haystack.slice(0, -needle.length)\n    : haystack\n}\n\nconst KEBAB_REGEX = /[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g\n\nexport const kebabCase = (str: string): string => {\n  return str.replace(KEBAB_REGEX, (match) => `-${match.toLowerCase()}`)\n}\n\nconst SPACES_REGEXP = /[\\t\\r\\n\\u0085\\u2028\\u2029]+/g\n\nexport const replaceSpaces = (str: string): string => {\n  return str.replace(SPACES_REGEXP, ' ')\n}\n","// Inspired by https://github.com/reactjs/react-magic/blob/master/src/htmltojsx.js\nimport * as t from '@babel/types'\nimport { hyphenToCamelCase, isNumeric, trimEnd } from './util'\n\nconst PX_REGEX = /^\\d+px$/\nconst MS_REGEX = /^-ms-/\nconst VAR_REGEX = /^--/\n\n/**\n * Determines if the CSS value can be converted from a\n * 'px' suffixed string to a numeric value.\n */\nconst isConvertiblePixelValue = (value: string) => {\n  return PX_REGEX.test(value)\n}\n\n/**\n * Format style key into JSX style object key.\n */\nconst formatKey = (key: string) => {\n  if (VAR_REGEX.test(key)) {\n    return t.stringLiteral(key)\n  }\n  key = key.toLowerCase()\n  // Don't capitalize -ms- prefix\n  if (MS_REGEX.test(key)) key = key.substr(1)\n  return t.identifier(hyphenToCamelCase(key))\n}\n\n/**\n * Format style value into JSX style object value.\n */\nconst formatValue = (value: string) => {\n  if (isNumeric(value)) return t.numericLiteral(Number(value))\n  if (isConvertiblePixelValue(value))\n    return t.numericLiteral(Number(trimEnd(value, 'px')))\n  return t.stringLiteral(value)\n}\n\n/**\n * Handle parsing of inline styles.\n */\nexport const stringToObjectStyle = (rawStyle: string): t.ObjectExpression => {\n  const entries = rawStyle.split(';')\n  const properties = []\n\n  let index = -1\n\n  while (++index < entries.length) {\n    const entry = entries[index]\n    const style = entry.trim()\n    const firstColon = style.indexOf(':')\n    const value = style.substr(firstColon + 1).trim()\n    const key = style.substr(0, firstColon)\n    if (key !== '') {\n      const property = t.objectProperty(formatKey(key), formatValue(value))\n      properties.push(property)\n    }\n  }\n\n  return t.objectExpression(properties)\n}\n","// From https://raw.githubusercontent.com/facebook/react/master/packages/react-dom/src/shared/possibleStandardNames.js\nexport const ATTRIBUTE_MAPPING = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'c